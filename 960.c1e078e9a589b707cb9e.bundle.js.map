{"version":3,"file":"960.c1e078e9a589b707cb9e.bundle.js","mappings":"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","sources":["webpack://tweb/./src/config/debug.ts","webpack://tweb/./src/config/modes.ts","webpack://tweb/./src/environment/ctx.ts","webpack://tweb/./src/helpers/array/findAndSplice.ts","webpack://tweb/./src/helpers/array/indexOfAndSplice.ts","webpack://tweb/./src/helpers/bytes/bufferConcats.ts","webpack://tweb/./src/helpers/context.ts","webpack://tweb/./src/helpers/dT.ts","webpack://tweb/./src/helpers/eventListenerBase.ts","webpack://tweb/./src/lib/crypto/cryptoMessagePort.ts","webpack://tweb/./src/lib/mtproto/superMessagePort.ts","webpack://tweb/./src/lib/polyfill.ts"],"sourcesContent":["/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport Modes from \"./modes\";\r\n\r\nexport const DEBUG = (process.env.NODE_ENV !== 'production' || Modes.debug)/*  && false */;\r\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\r\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\r\nexport default DEBUG;\r\n\r\n//let m = DEBUG;\r\n/* if(!DEBUG) {\r\n  ctx.sandpitTurtle = () => {\r\n    //if(!m) {\r\n      for(let i in MOUNT_CLASS_TO) {\r\n        ctx[i] = MOUNT_CLASS_TO[i];\r\n      }\r\n      //m = true;\r\n    //}\r\n  \r\n    //DEBUG = !DEBUG;\r\n  };\r\n} */\r\n\r\n/* export const superDebug = (object: any, key: string) => {\r\n  var d = object[key];\r\n  var beforeStr = '', afterStr = '';\r\n  for(var r of d) {\r\n    beforeStr += r.before.hex + '\\n';\r\n    afterStr += r.after.hex + '\\n';\r\n  }\r\n\r\n  beforeStr = beforeStr.trim();\r\n  afterStr = afterStr.trim();\r\n  //var beforeStr = d.map((r) => r.before.hex).join('\\n');\r\n  //var afterStr = d.map((r) => r.after.hex).join('\\n');\r\n\r\n  var dada = (name: string, str: string) => {\r\n    var a = document.createElement('a');\r\n    a.target = '_blank';\r\n    a.download = name + '.txt';\r\n    a.href = URL.createObjectURL(new Blob([str], {\r\n      type: 'text/plain'\r\n    }));\r\n    document.body.append(a);\r\n    a.click();\r\n  };\r\n\r\n  dada(key + '_' + 'before', beforeStr);\r\n  dada(key + '_' + 'after', afterStr);\r\n}\r\n\r\nMOUNT_CLASS_TO.superDebug = superDebug; */\r\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport type { TransportType } from \"../lib/mtproto/dcConfigurator\";\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  multipleConnections: true,\n  asServiceWorker: false,\n  transport: 'websocket' as TransportType\n};\n\n                        \nModes.http = location.search.indexOf('http=1') > 0;\n          \n\n                                       \n                  \n          \n\nif(Modes.http) {\n  Modes.transport = 'https';\n}\n\n                  \n                             \n          \n\nexport default Modes;\n","const ctx = typeof(window) !== 'undefined' ? window : self;\r\n\r\nexport default ctx;\r\n","export default function findAndSplice<T>(array: Array<T>, verify: (value: T, index?: number, array?: Array<T>) => boolean) {\r\n  const index = array.findIndex(verify);\r\n  return index !== -1 ? array.splice(index, 1)[0] : undefined;\r\n};\r\n","export default function indexOfAndSplice<T>(array: Array<T>, item: T) {\r\n  const idx = array.indexOf(item);\r\n  const spliced = idx !== -1 && array.splice(idx, 1);\r\n  return spliced && spliced[0];\r\n}\r\n","export default function bufferConcats(...args: (ArrayBuffer | Uint8Array | number[])[]) {\r\n  const length = args.reduce((acc, v) => acc + ((v as ArrayBuffer).byteLength || (v as Uint8Array).length), 0);\r\n\r\n  const tmp = new Uint8Array(length);\r\n  \r\n  let lastLength = 0;\r\n  args.forEach((b) => {\r\n    tmp.set(b instanceof ArrayBuffer ? new Uint8Array(b) : b, lastLength);\r\n    lastLength += (b as ArrayBuffer).byteLength || (b as Uint8Array).length;\r\n  });\r\n\r\n  return tmp/* .buffer */;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// в SW может быть сразу две переменных TRUE\r\nexport const IS_SERVICE_WORKER = typeof ServiceWorkerGlobalScope !== 'undefined' && self instanceof ServiceWorkerGlobalScope;\r\nexport const IS_WEB_WORKER = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && !IS_SERVICE_WORKER;\r\nexport const IS_WORKER = IS_WEB_WORKER || IS_SERVICE_WORKER;\r\n\r\nexport const getWindowClients = () => {\r\n  return (self as any as ServiceWorkerGlobalScope)\r\n  .clients\r\n  .matchAll({includeUncontrolled: false, type: 'window'});\r\n};\r\n\r\nconst postMessage = (listener: WindowClient | DedicatedWorkerGlobalScope, ...args: any[]) => {\r\n  try {\r\n    // @ts-ignore\r\n    listener.postMessage(...args);\r\n  } catch(err) {\r\n    console.error('[worker] postMessage error:', err, args);\r\n  }\r\n};\r\n\r\nconst notifyServiceWorker = (all: boolean, ...args: any[]) => {\r\n  getWindowClients().then((listeners) => {\r\n    if(!listeners.length) {\r\n      //console.trace('no listeners?', self, listeners);\r\n      return;\r\n    }\r\n\r\n    listeners.slice(all ? 0 : -1).forEach((listener) => {\r\n      postMessage(listener, ...args);\r\n    });\r\n  });\r\n};\r\n\r\nconst notifyWorker = (...args: any[]) => {\r\n  postMessage(self as any as DedicatedWorkerGlobalScope, ...args);\r\n};\r\n\r\nconst noop = () => {};\r\n\r\nexport const notifySomeone = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, false) : (IS_WEB_WORKER ? notifyWorker : noop);\r\nexport const notifyAll = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, true) : (IS_WEB_WORKER ? notifyWorker : noop);\r\n","const _logTimer = Date.now();\r\nexport default function dT() {\r\n  return '[' + ((Date.now() - _logTimer) / 1000).toFixed(3) + ']';\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n//import { MOUNT_CLASS_TO } from \"../config/debug\";\r\nimport type { ArgumentTypes, SuperReturnType } from \"../types\";\r\nimport findAndSplice from \"./array/findAndSplice\";\r\n\r\n// class EventSystem {\r\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\r\n\r\n//   add(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (listeners === undefined) {\r\n//         listeners = {};\r\n//     }\r\n//     let listenersForEvent = listeners[event];\r\n//     if (listenersForEvent === undefined) {\r\n//         listenersForEvent = new Set();\r\n//     }\r\n//     listenersForEvent.add(listener);\r\n//     listeners[event] = listenersForEvent;\r\n//     //target.addEventListener(event, listener);\r\n//     this.wm.set(target, listeners);\r\n//   };\r\n\r\n//   remove(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (!listeners) return;\r\n//     let listenersForEvent = listeners[event];\r\n//     if (!listenersForEvent) return;\r\n//     listenersForEvent.delete(listener);\r\n//   };\r\n  \r\n//   /* fire(target, event) {\r\n//      let listeners = this.wm.get(target);\r\n//      if (!listeners) return;\r\n//      let listenersForEvent = listeners[event];\r\n//      if (!listenersForEvent) return;\r\n//      for (let handler of handlers) {\r\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous. \r\n//      }\r\n//   }; */\r\n// }\r\n\r\n// console.log = () => {};\r\n\r\n// const e = new EventSystem();\r\n// MOUNT_CLASS_TO.e = e;\r\n\r\nexport type EventListenerListeners = Record<string, Function>;\r\n// export type EventListenerListeners = Record<string, (...args: any[]) => any>;\r\n// export type EventListenerListeners = {[name in string]: Function};\r\n\r\n/**\r\n * Better not to remove listeners during setting\r\n * Should add listener callback only once\r\n */\r\n\r\ntype ListenerObject<T> = {callback: T, options: boolean | AddEventListenerOptions};\r\n\r\n// type EventLitenerCallback<T> = (data: T) => \r\n// export default class EventListenerBase<Listeners extends {[name: string]: Function}> {\r\nexport default class EventListenerBase<Listeners extends EventListenerListeners> {\r\n  protected listeners: Partial<{\r\n    [k in keyof Listeners]: Array<ListenerObject<Listeners[k]>>\r\n  }>;\r\n  protected listenerResults: Partial<{\r\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\r\n  }>;\r\n\r\n  private reuseResults: boolean;\r\n\r\n  constructor(reuseResults?: boolean) {\r\n    this._constructor(reuseResults);\r\n  }\r\n\r\n  public _constructor(reuseResults = false): any {\r\n    this.reuseResults = reuseResults;\r\n    this.listeners = {};\r\n    this.listenerResults = {};\r\n  }\r\n\r\n  public addEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\r\n    (this.listeners[name] ?? (this.listeners[name] = [])).push({callback, options}); // ! add before because if you don't, you won't be able to delete it from callback\r\n\r\n    if(this.listenerResults.hasOwnProperty(name)) {\r\n      callback(...this.listenerResults[name]);\r\n      \r\n      if((options as AddEventListenerOptions)?.once) {\r\n        this.listeners[name].pop();\r\n        return;\r\n      }\r\n    }\r\n    \r\n    //e.add(this, name, {callback, once});\r\n  }\r\n\r\n  public addMultipleEventsListeners(obj: {\r\n    [name in keyof Listeners]?: Listeners[name]\r\n  }) {\r\n    for(const i in obj) {\r\n      this.addEventListener(i, obj[i]);\r\n    }\r\n  }\r\n\r\n  public removeEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\r\n    if(this.listeners[name]) {\r\n      findAndSplice(this.listeners[name], l => l.callback === callback);\r\n    }\r\n    //e.remove(this, name, callback);\r\n  }\r\n\r\n  protected invokeListenerCallback<T extends keyof Listeners, L extends ListenerObject<any>>(name: T, listener: L, ...args: ArgumentTypes<L['callback']>) {\r\n    let result: any;\r\n    try {\r\n      result = listener.callback(...args);\r\n    } catch(err) {\r\n      console.error(err);\r\n    }\r\n\r\n    if((listener.options as AddEventListenerOptions)?.once) {\r\n      this.removeEventListener(name, listener.callback);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private _dispatchEvent<T extends keyof Listeners>(name: T, collectResults: boolean, ...args: ArgumentTypes<Listeners[T]>) {\r\n    if(this.reuseResults) {\r\n      this.listenerResults[name] = args;\r\n    }\r\n\r\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = collectResults && [];\r\n\r\n    const listeners = this.listeners[name];\r\n    if(listeners) {\r\n      // ! this one will guarantee execution even if delete another listener during setting\r\n      const left = listeners.slice();\r\n      left.forEach((listener) => {\r\n        const index = listeners.findIndex((l) => l.callback === listener.callback);\r\n        if(index === -1) {\r\n          return;\r\n        }\r\n\r\n        const result = this.invokeListenerCallback(name, listener, ...args);\r\n        if(arr) {\r\n          arr.push(result);\r\n        }\r\n      });\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  public dispatchResultableEvent<T extends keyof Listeners>(name: T, ...args: ArgumentTypes<Listeners[T]>) {\r\n    return this._dispatchEvent(name, true, ...args);\r\n  }\r\n\r\n  // * must be protected, but who cares\r\n  public dispatchEvent<L extends EventListenerListeners = Listeners, T extends keyof L = keyof L>(name: T, ...args: ArgumentTypes<L[T]>) {\r\n    // @ts-ignore\r\n    this._dispatchEvent(name, false, ...args);\r\n  }\r\n\r\n  public cleanup() {\r\n    this.listeners = {}; \r\n    this.listenerResults = {};\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport { CryptoMethods } from './crypto_methods';\r\nimport SuperMessagePort from '../mtproto/superMessagePort';\r\nimport { Awaited } from '../../types';\r\nimport { MOUNT_CLASS_TO } from '../../config/debug';\r\nimport { IS_WORKER } from '../../helpers/context';\r\n\r\ntype CryptoEvent = {\r\n  invoke: <T extends keyof CryptoMethods>(payload: {method: T, args: Parameters<CryptoMethods[T]>}) => ReturnType<CryptoMethods[T]>,\r\n  port: (payload: void, source: MessageEventSource, event: MessageEvent) => void\r\n};\r\n\r\nexport class CryptoMessagePort<Master extends boolean = false> extends SuperMessagePort<CryptoEvent, CryptoEvent, Master> {\r\n  public invokeCrypto<T extends keyof CryptoMethods>(method: T, ...args: Parameters<CryptoMethods[T]>): Promise<Awaited<ReturnType<CryptoMethods[T]>>> {\r\n    const payload = {method, args};\r\n    const listeners = this.listeners['invoke'];\r\n    if(listeners?.length) { // already in worker\r\n      // try {\r\n        // @ts-ignore\r\n        let result: any = listeners[0].callback(payload);\r\n        if(!IS_WORKER && !(result instanceof Promise)) {\r\n          result = Promise.resolve(result);\r\n        }\r\n\r\n        return result;\r\n      // } catch(err) {\r\n      //   return Promise.reject(err);\r\n      // }\r\n    }\r\n\r\n    // @ts-ignore\r\n    return this.invoke('invoke', payload);\r\n  }\r\n}\r\n\r\nconst cryptoMessagePort = new CryptoMessagePort<false>();\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.cryptoMessagePort = cryptoMessagePort);\r\nexport default cryptoMessagePort;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport DEBUG from \"../../config/debug\";\r\nimport ctx from \"../../environment/ctx\";\r\nimport indexOfAndSplice from \"../../helpers/array/indexOfAndSplice\";\r\nimport { IS_SERVICE_WORKER, IS_WORKER, notifyAll } from \"../../helpers/context\";\r\nimport EventListenerBase from \"../../helpers/eventListenerBase\";\r\nimport { Awaited, WorkerTaskTemplate, WorkerTaskVoidTemplate } from \"../../types\";\r\nimport { logger } from \"../logger\";\r\n\r\ntype SuperMessagePortTask = WorkerTaskTemplate & {\r\n  transfer?: Transferable[]\r\n};\r\n\r\ninterface InvokeTask extends SuperMessagePortTask {\r\n  type: 'invoke',\r\n  payload: WorkerTaskVoidTemplate & {withAck?: boolean, void?: boolean}\r\n}\r\n\r\ninterface ResultTask extends SuperMessagePortTask {\r\n  type: 'result',\r\n  payload: {\r\n    taskId: number,\r\n    result?: any,\r\n    error?: any\r\n  }\r\n}\r\n\r\ninterface AckTask extends SuperMessagePortTask {\r\n  type: 'ack',\r\n  payload: {\r\n    cached: boolean,\r\n    taskId: number\r\n    result?: any,\r\n    error?: any,\r\n  }\r\n}\r\n\r\ninterface PingTask extends SuperMessagePortTask {\r\n  type: 'ping'\r\n}\r\n\r\ninterface PongTask extends SuperMessagePortTask {\r\n  type: 'pong'\r\n}\r\n\r\ninterface BatchTask extends SuperMessagePortTask {\r\n  type: 'batch',\r\n  payload: Task[]\r\n}\r\n\r\ninterface CloseTask extends SuperMessagePortTask {\r\n  type: 'close'\r\n}\r\n\r\ntype Task = InvokeTask | ResultTask | AckTask | PingTask | PongTask | BatchTask | CloseTask;\r\ntype TaskMap = {\r\n  [type in Task as type['type']]?: (task: Extract<Task, type>, source: MessageEventSource, event: MessageEvent<any>) => void | Promise<any>\r\n};\r\n\r\nexport type AckedResult<T> = {\r\n  cached: boolean,\r\n  result: Promise<T>\r\n};\r\n// export type AckedResult<T> = {\r\n//   cached: true,\r\n//   result: T\r\n// } | {\r\n//   cached: false,\r\n//   result: Promise<T>\r\n// };\r\n\r\ntype ListenPort = WindowProxy | MessagePort | ServiceWorker | Worker | ServiceWorkerContainer;\r\ntype SendPort = WindowProxy | MessagePort | ServiceWorker | Worker;\r\n\r\ntype ListenerCallback = (payload: any, source: MessageEventSource, event: MessageEvent<any>) => any;\r\ntype Listeners = Record<string, ListenerCallback>;\r\n\r\n// const PING_INTERVAL = DEBUG && false ? 0x7FFFFFFF : 5000;\r\n// const PING_TIMEOUT = DEBUG && false ? 0x7FFFFFFF : 10000;\r\n\r\nexport default class SuperMessagePort<\r\n  Workers extends Listeners, \r\n  Masters extends Listeners,\r\n  IsMaster extends boolean,\r\n  Receive extends Listeners = IsMaster extends true ? Masters : Workers,\r\n  Send extends Listeners = IsMaster extends true ? Workers : Masters\r\n> extends EventListenerBase<Receive> {\r\n  protected listenPorts: Array<ListenPort>;\r\n  protected sendPorts: Array<SendPort>;\r\n  protected pingResolves: Map<SendPort, () => void>;\r\n\r\n  protected taskId: number;\r\n  protected awaiting: {\r\n    [id: number]: {\r\n      resolve: any,\r\n      reject: any,\r\n      taskType: string\r\n    }\r\n  };\r\n  protected pending: Map<SendPort, Task[]>;\r\n\r\n  protected log: ReturnType<typeof logger>;\r\n  protected debug: boolean;\r\n  protected releasingPending: boolean;\r\n\r\n  protected processTaskMap: TaskMap;\r\n\r\n  protected onPortDisconnect: (source: MessageEventSource) => void;\r\n\r\n  constructor() {\r\n    super(false);\r\n\r\n    this.processTaskMap = {\r\n      result: this.processResultTask,\r\n      ack: this.processAckTask,\r\n      invoke: this.processInvokeTask,\r\n      ping: this.processPingTask,\r\n      pong: this.processPongTask,\r\n      close: this.processCloseTask\r\n    };\r\n  }\r\n\r\n  public _constructor() {\r\n    super._constructor(false);\r\n\r\n    this.listenPorts = [];\r\n    this.sendPorts = [];\r\n    this.pingResolves = new Map();\r\n    this.taskId = 0;\r\n    this.awaiting = {};\r\n    this.pending = new Map();\r\n    this.log = logger('MP');\r\n    this.debug = DEBUG;\r\n\r\n    if(typeof(window) !== 'undefined') {\r\n      window.addEventListener('beforeunload', () => {\r\n        const task = this.createTask('close', undefined);\r\n        this.postMessage(undefined, task);\r\n      });\r\n    }\r\n  }\r\n\r\n  public setOnPortDisconnect(callback: (source: MessageEventSource) => void) {\r\n    this.onPortDisconnect = callback;\r\n  }\r\n\r\n  public attachPort(port: MessageEventSource) {\r\n    this.attachListenPort(port);\r\n    this.attachSendPort(port);\r\n  }\r\n\r\n  public attachListenPort(port: ListenPort) {\r\n    this.listenPorts.push(port);\r\n    port.addEventListener('message', this.onMessage as any);\r\n  }\r\n\r\n  public attachSendPort(port: SendPort) {\r\n    this.log.warn('attaching port');\r\n\r\n    if((port as MessagePort).start) {\r\n      (port as MessagePort).start();\r\n    }\r\n\r\n    this.sendPorts.push(port);\r\n    // this.sendPing(port);\r\n  }\r\n\r\n  // ! Can't rely on ping because timers can be suspended\r\n  // protected sendPing(port: SendPort, loop = IS_WORKER) {\r\n  //   let timeout: number;\r\n  //   const promise = new Promise<void>((resolve, reject) => {\r\n  //     this.pingResolves.set(port, resolve);\r\n  //     this.pushTask(this.createTask('ping', undefined), port);\r\n\r\n  //     timeout = ctx.setTimeout(() => {\r\n  //       reject();\r\n  //     }, PING_TIMEOUT);\r\n  //   });\r\n\r\n  //   promise.then(() => {\r\n  //     // this.log('got pong');\r\n\r\n  //     clearTimeout(timeout);\r\n  //     this.pingResolves.delete(port);\r\n\r\n  //     if(loop) {\r\n  //       this.sendPingWithTimeout(port);\r\n  //     }\r\n  //   }, () => {\r\n  //     this.pingResolves.delete(port);\r\n  //     this.detachPort(port);\r\n  //   });\r\n  // }\r\n\r\n  // protected sendPingWithTimeout(port: SendPort, timeout = PING_INTERVAL) {\r\n  //   ctx.setTimeout(() => {\r\n  //     if(!this.sendPorts.includes(port)) {\r\n  //       return;\r\n  //     }\r\n\r\n  //     this.sendPing(port);\r\n  //   }, timeout);\r\n  // }\r\n\r\n  protected detachPort(port: SendPort) {\r\n    this.log.warn('disconnecting port');\r\n    \r\n    port.removeEventListener('message', this.onMessage as any);\r\n    indexOfAndSplice(this.listenPorts, port);\r\n    indexOfAndSplice(this.sendPorts, port);\r\n    if((port as MessagePort).close) {\r\n      (port as MessagePort).close();\r\n    }\r\n\r\n    this.onPortDisconnect && this.onPortDisconnect(port as any);\r\n  }\r\n\r\n  protected postMessage(port: SendPort | SendPort[], task: Task) {\r\n    const ports = Array.isArray(port) ? port : (port ? [port] : this.sendPorts);\r\n    ports.forEach((port) => {\r\n      port.postMessage(task, task.transfer as any);\r\n    });\r\n  }\r\n\r\n  protected onMessage = (event: MessageEvent) => {\r\n    const task: Task = event.data;\r\n    // this.log('got message', task);\r\n\r\n    const source: MessageEventSource = event.source || event.currentTarget as any; // can have no source\r\n    /* if(task.type === 'batch') {\r\n      const newEvent: MessageEvent = {data: event.data, source: event.source, currentTarget: event.currentTarget} as any;\r\n      task.payload.forEach((task) => {\r\n        // @ts-ignore\r\n        newEvent.data = task;\r\n        this.onMessage(newEvent);\r\n      });\r\n    } */\r\n\r\n    // @ts-ignore\r\n    this.processTaskMap[task.type](task, source, event);\r\n  };\r\n\r\n  protected /* async */ releasePending() {\r\n    //return;\r\n\r\n    if(!this.listenPorts.length || this.releasingPending) {\r\n      return;\r\n    }\r\n\r\n    this.releasingPending = true;\r\n    // const perf = performance.now();\r\n    // await pause(0);\r\n\r\n    this.debug && this.log.debug('releasing tasks, length:', this.pending.size/* , performance.now() - perf */);\r\n\r\n    this.pending.forEach((portTasks, port) => {\r\n      // let batchTask: BatchTask;\r\n      // const tasks: Task[] = [];\r\n      // portTasks.forEach((task) => {\r\n      //   if(task.transfer) {\r\n      //     batchTask = undefined;\r\n      //     tasks.push(task);\r\n      //   } else {\r\n      //     if(!batchTask) {\r\n      //       batchTask = this.createTask('batch', []);\r\n      //       tasks.push(batchTask);\r\n      //     }\r\n\r\n      //     batchTask.payload.push(task);\r\n      //   }\r\n      // });\r\n\r\n      const tasks = portTasks;\r\n\r\n      tasks.forEach((task) => {\r\n        // if(task.type === 'batch') {\r\n        //   this.log(`batching ${task.payload.length} tasks`);\r\n        // }\r\n\r\n        try {\r\n          if(IS_SERVICE_WORKER) {\r\n            notifyAll(task);\r\n          } else {\r\n            this.postMessage(port, task);\r\n          }\r\n        } catch(err) {\r\n          this.log.error('postMessage error:', err, task, port);\r\n        }\r\n      });\r\n    });\r\n\r\n    this.debug && this.log.debug('released tasks');\r\n    this.pending.clear();\r\n\r\n    this.releasingPending = false;\r\n  }\r\n\r\n  protected processResultTask = (task: ResultTask) => {\r\n    const {taskId, result, error} = task.payload;\r\n    const deferred = this.awaiting[taskId];\r\n    if(!deferred) {\r\n      return;\r\n    }\r\n\r\n    this.debug && this.log.debug('done', deferred.taskType, result, error);\r\n    'error' in task.payload ? deferred.reject(error) : deferred.resolve(result);\r\n    delete this.awaiting[taskId];\r\n  };\r\n\r\n  protected processAckTask = (task: AckTask) => {\r\n    const payload = task.payload;\r\n    const deferred = this.awaiting[payload.taskId];\r\n    if(!deferred) {\r\n      return;\r\n    }\r\n\r\n    // * will finish the init promise with incoming result\r\n    const previousResolve: (acked: AckedResult<any>) => void = deferred.resolve;\r\n    // const previousReject = deferred.reject;\r\n\r\n    // if(payload.cached) {\r\n    //   if('result' in payload) {\r\n    //     previousResolve({\r\n    //       cached: true,\r\n    //       result: payload.result\r\n    //     });\r\n    //   } else {\r\n    //     previousReject(payload.error);\r\n    //   }\r\n    // } else {\r\n    //   const ret: AckedResult<any> = {\r\n    //     cached: false,\r\n    //     result: new Promise((resolve, reject) => {\r\n    //       deferred.resolve = resolve;\r\n    //       deferred.reject = reject;\r\n    //     })\r\n    //   };\r\n\r\n    //   previousResolve(ret);\r\n    // }\r\n\r\n    const ret: AckedResult<any> = {\r\n      cached: payload.cached,\r\n      result: payload.cached ? ('result' in payload ? Promise.resolve(payload.result) : Promise.reject(payload.error)) : new Promise((resolve, reject) => {\r\n        deferred.resolve = resolve;\r\n        deferred.reject = reject;\r\n      })\r\n    };\r\n\r\n    previousResolve(ret);\r\n  };\r\n\r\n  protected processPingTask = (task: PingTask, source: MessageEventSource, event: MessageEvent) => {\r\n    this.pushTask(this.createTask('pong', undefined), event.source);\r\n  };\r\n\r\n  protected processPongTask = (task: PongTask, source: MessageEventSource, event: MessageEvent) => {\r\n    const pingResolve = this.pingResolves.get(source);\r\n    if(pingResolve) {\r\n      this.pingResolves.delete(source);\r\n      pingResolve();\r\n    }\r\n  };\r\n\r\n  protected processCloseTask = (task: CloseTask, source: MessageEventSource, event: MessageEvent) => {\r\n    this.detachPort(source);\r\n  };\r\n\r\n  protected processInvokeTask = async(task: InvokeTask, source: MessageEventSource, event: MessageEvent) => {\r\n    const id = task.id;\r\n    const innerTask = task.payload;\r\n    \r\n    let resultTaskPayload: ResultTask['payload'];\r\n    let resultTask: ResultTask, ackTask: AckTask;\r\n    if(!innerTask.void) {\r\n      resultTaskPayload = {taskId: id};\r\n      resultTask = this.createTask('result', resultTaskPayload);\r\n    }\r\n\r\n    if(innerTask.withAck) {\r\n      ackTask = this.createTask('ack', {\r\n        taskId: id,\r\n        cached: true\r\n      });\r\n    }\r\n\r\n    let isPromise: boolean;\r\n    try {\r\n      const listeners = this.listeners[innerTask.type];\r\n      if(!listeners?.length) {\r\n        throw new Error('no listener');\r\n      }\r\n\r\n      const listener = listeners[0];\r\n\r\n      // @ts-ignore\r\n      let result = this.invokeListenerCallback(innerTask.type, listener, innerTask.payload, source, event);\r\n      if(innerTask.void) {\r\n        return;\r\n      }\r\n\r\n      isPromise = result instanceof Promise;\r\n\r\n      if(ackTask) {\r\n        const cached = !isPromise;\r\n        ackTask.payload.cached = cached;\r\n        if(cached) ackTask.payload.result = result;\r\n        this.pushTask(ackTask, source);\r\n\r\n        if(cached) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      if(isPromise) {\r\n        result = await result;\r\n      }\r\n  \r\n      resultTaskPayload.result = result;\r\n    } catch(error) {\r\n      this.log.error('worker task error:', error, task);\r\n      if(innerTask.void) {\r\n        return;\r\n      }\r\n\r\n      if(ackTask && ackTask.payload.cached) {\r\n        ackTask.payload.error = error;\r\n        this.pushTask(ackTask, source);\r\n        return;\r\n      }\r\n\r\n      resultTaskPayload.error = error;\r\n    }\r\n\r\n    this.pushTask(resultTask, source);\r\n  };\r\n\r\n  protected createTask<T extends Task['type'], K extends Task = Parameters<TaskMap[T]>[0]>(type: T, payload: K['payload'], transfer?: Transferable[]): K {\r\n    return {\r\n      type,\r\n      payload,\r\n      id: this.taskId++,\r\n      transfer\r\n    } as K;\r\n  }\r\n\r\n  protected createInvokeTask(type: string, payload: any, withAck?: boolean, _void?: boolean, transfer?: Transferable[]): InvokeTask {\r\n    return this.createTask('invoke', {\r\n      type,\r\n      payload,\r\n      withAck,\r\n      void: _void\r\n    }, transfer);\r\n  }\r\n\r\n  protected pushTask(task: Task, port?: SendPort) {\r\n    let tasks = this.pending.get(port);\r\n    if(!tasks) {\r\n      this.pending.set(port, tasks = []);\r\n    }\r\n\r\n    tasks.push(task);\r\n    this.releasePending();\r\n  }\r\n\r\n  public invokeVoid<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], port?: SendPort, transfer?: Transferable[]) {\r\n    const task = this.createInvokeTask(type as string, payload, undefined, true, transfer);\r\n    this.pushTask(task, port);\r\n  }\r\n\r\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: false, port?: SendPort, transfer?: Transferable[]): Promise<Awaited<ReturnType<Send[T]>>>;\r\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: true, port?: SendPort, transfer?: Transferable[]): Promise<AckedResult<Awaited<ReturnType<Send[T]>>>>;\r\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: boolean, port?: SendPort, transfer?: Transferable[]) {\r\n    this.debug && this.log.debug('start', type, payload);\r\n\r\n    let task: InvokeTask;\r\n    const promise = new Promise<Awaited<ReturnType<Send[T]>>>((resolve, reject) => {\r\n      task = this.createInvokeTask(type as string, payload, withAck, undefined, transfer);\r\n      this.awaiting[task.id] = {resolve, reject, taskType: type as string};\r\n      this.pushTask(task, port);\r\n    });\r\n\r\n    if(IS_WORKER) {\r\n      promise.finally(() => {\r\n        clearInterval(interval);\r\n      });\r\n  \r\n      const interval = ctx.setInterval(() => {\r\n        this.log.error('task still has no result', task, port);\r\n      }, 5e3);\r\n    } else if(false) {\r\n      // let timedOut = false;\r\n      const startTime = Date.now();\r\n      promise.finally(() => {\r\n        const elapsedTime = Date.now() - startTime;\r\n        if(elapsedTime >= TIMEOUT) {\r\n          this.log.error(`task was processing ${Date.now() - startTime}ms`, task.payload.payload, port);\r\n        }/*  else {\r\n          clearTimeout(timeout);\r\n        } */\r\n      });\r\n\r\n      const TIMEOUT = 10;\r\n      // const timeout = ctx.setTimeout(() => {\r\n      //   timedOut = true;\r\n      //   // this.log.error(`task is processing more than ${TIMEOUT} milliseconds`, task, port);\r\n      // }, TIMEOUT);\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  public invokeExceptSource<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], source?: SendPort) {\r\n    const ports = this.sendPorts.slice();\r\n    indexOfAndSplice(ports, source);\r\n\r\n    ports.forEach((target) => {\r\n      this.invokeVoid(type, payload, target);\r\n    });\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport bufferConcats from \"../helpers/bytes/bufferConcats\";\r\n\r\nUint8Array.prototype.concat = function(...args: Array<Uint8Array | ArrayBuffer | number[]>) {\r\n  return bufferConcats(this, ...args);\r\n};\r\n\r\n/* Uint8Array.prototype.toString = function() {\r\n  return String.fromCharCode.apply(null, [...this]);\r\n}; */\r\n\r\nUint8Array.prototype.toJSON = function() {\r\n  return [...this];\r\n  //return {type: 'bytes', value: [...this]};\r\n};\r\n\r\nPromise.prototype.finally = Promise.prototype.finally || function<T>(this: Promise<T>, fn: () => any) {\r\n  const onFinally = (callback: typeof fn) => Promise.resolve(fn()).then(callback);\r\n  return this.then(\r\n    result => onFinally(() => result),\r\n    reason => onFinally(() => Promise.reject(reason))\r\n  );\r\n};\r\n\r\ndeclare global {\r\n  interface Uint8Array {\r\n    concat: (...args: Array<Uint8Array | ArrayBuffer | number[]>) => Uint8Array,\r\n    //toString: () => string,\r\n    toJSON: () => number[],\r\n    //toJSON: () => {type: 'bytes', value: number[]},\r\n  }\r\n  \r\n  interface Promise<T> {\r\n    finally: (onfinally?: () => void) => Promise<T>;\r\n  }\r\n}\r\n"],"names":["DEBUG","MOUNT_CLASS_TO","window","self","Modes","test","location","search","indexOf","debug","http","ssl","multipleConnections","asServiceWorker","transport","findAndSplice","array","verify","index","findIndex","splice","undefined","indexOfAndSplice","item","idx","spliced","bufferConcats","args","length","reduce","acc","v","byteLength","tmp","Uint8Array","lastLength","forEach","b","set","ArrayBuffer","IS_SERVICE_WORKER","ServiceWorkerGlobalScope","IS_WEB_WORKER","WorkerGlobalScope","IS_WORKER","postMessage","listener","err","console","error","notifyServiceWorker","all","clients","matchAll","includeUncontrolled","type","then","listeners","slice","notifyAll","bind","_logTimer","Date","now","dT","toFixed","EventListenerBase","constructor","reuseResults","this","_constructor","listenerResults","addEventListener","name","callback","options","push","hasOwnProperty","once","pop","addMultipleEventsListeners","obj","i","removeEventListener","l","invokeListenerCallback","result","_dispatchEvent","collectResults","arr","dispatchResultableEvent","dispatchEvent","cleanup","CryptoMessagePort","invokeCrypto","method","payload","Promise","resolve","invoke","cryptoMessagePort","SuperMessagePort","super","onMessage","event","task","data","source","currentTarget","processTaskMap","processResultTask","taskId","deferred","awaiting","log","taskType","reject","processAckTask","previousResolve","cached","processPingTask","pushTask","createTask","processPongTask","pingResolve","pingResolves","get","delete","processCloseTask","detachPort","processInvokeTask","id","innerTask","resultTaskPayload","resultTask","ackTask","isPromise","void","withAck","Error","ack","ping","pong","close","listenPorts","sendPorts","Map","pending","setOnPortDisconnect","onPortDisconnect","attachPort","port","attachListenPort","attachSendPort","warn","start","Array","isArray","transfer","releasePending","releasingPending","size","portTasks","clear","createInvokeTask","_void","tasks","invokeVoid","promise","finally","clearInterval","interval","invokeExceptSource","ports","target","prototype","concat","toJSON","fn","onFinally","reason"],"sourceRoot":""}