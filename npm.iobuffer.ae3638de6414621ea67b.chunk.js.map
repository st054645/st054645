{"version":3,"file":"npm.iobuffer.ae3638de6414621ea67b.chunk.js","mappings":"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","sources":["webpack://tweb/./node_modules/iobuffer/lib-esm/utf8.browser.js","webpack://tweb/./node_modules/iobuffer/lib-esm/IOBuffer.js","webpack://tweb/./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js"],"sourcesContent":["// eslint-disable-next-line import/no-unassigned-import\nimport './text-encoding-polyfill';\nconst decoder = new TextDecoder('utf-8');\nexport function decode(bytes) {\n    return decoder.decode(bytes);\n}\nconst encoder = new TextEncoder();\nexport function encode(str) {\n    return encoder.encode(str);\n}\n//# sourceMappingURL=utf8.browser.js.map","import { decode, encode } from './utf8';\nconst defaultByteLength = 1024 * 8;\nexport class IOBuffer {\n    /**\n     * @param data - The data to construct the IOBuffer with.\n     * If data is a number, it will be the new buffer's length<br>\n     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\n     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\n     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\n     * @param options\n     */\n    constructor(data = defaultByteLength, options = {}) {\n        let dataIsGiven = false;\n        if (typeof data === 'number') {\n            data = new ArrayBuffer(data);\n        }\n        else {\n            dataIsGiven = true;\n            this.lastWrittenByte = data.byteLength;\n        }\n        const offset = options.offset ? options.offset >>> 0 : 0;\n        const byteLength = data.byteLength - offset;\n        let dvOffset = offset;\n        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n            if (data.byteLength !== data.buffer.byteLength) {\n                dvOffset = data.byteOffset + offset;\n            }\n            data = data.buffer;\n        }\n        if (dataIsGiven) {\n            this.lastWrittenByte = byteLength;\n        }\n        else {\n            this.lastWrittenByte = 0;\n        }\n        this.buffer = data;\n        this.length = byteLength;\n        this.byteLength = byteLength;\n        this.byteOffset = dvOffset;\n        this.offset = 0;\n        this.littleEndian = true;\n        this._data = new DataView(this.buffer, dvOffset, byteLength);\n        this._mark = 0;\n        this._marks = [];\n    }\n    /**\n     * Checks if the memory allocated to the buffer is sufficient to store more\n     * bytes after the offset.\n     * @param byteLength - The needed memory in bytes.\n     * @returns `true` if there is sufficient space and `false` otherwise.\n     */\n    available(byteLength = 1) {\n        return this.offset + byteLength <= this.length;\n    }\n    /**\n     * Check if little-endian mode is used for reading and writing multi-byte\n     * values.\n     * @returns `true` if little-endian mode is used, `false` otherwise.\n     */\n    isLittleEndian() {\n        return this.littleEndian;\n    }\n    /**\n     * Set little-endian mode for reading and writing multi-byte values.\n     */\n    setLittleEndian() {\n        this.littleEndian = true;\n        return this;\n    }\n    /**\n     * Check if big-endian mode is used for reading and writing multi-byte values.\n     * @returns `true` if big-endian mode is used, `false` otherwise.\n     */\n    isBigEndian() {\n        return !this.littleEndian;\n    }\n    /**\n     * Switches to big-endian mode for reading and writing multi-byte values.\n     */\n    setBigEndian() {\n        this.littleEndian = false;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes forward.\n     * @param n - Number of bytes to skip.\n     */\n    skip(n = 1) {\n        this.offset += n;\n        return this;\n    }\n    /**\n     * Move the pointer to the given offset.\n     * @param offset\n     */\n    seek(offset) {\n        this.offset = offset;\n        return this;\n    }\n    /**\n     * Store the current pointer offset.\n     * @see {@link IOBuffer#reset}\n     */\n    mark() {\n        this._mark = this.offset;\n        return this;\n    }\n    /**\n     * Move the pointer back to the last pointer offset set by mark.\n     * @see {@link IOBuffer#mark}\n     */\n    reset() {\n        this.offset = this._mark;\n        return this;\n    }\n    /**\n     * Push the current pointer offset to the mark stack.\n     * @see {@link IOBuffer#popMark}\n     */\n    pushMark() {\n        this._marks.push(this.offset);\n        return this;\n    }\n    /**\n     * Pop the last pointer offset from the mark stack, and set the current\n     * pointer offset to the popped value.\n     * @see {@link IOBuffer#pushMark}\n     */\n    popMark() {\n        const offset = this._marks.pop();\n        if (offset === undefined) {\n            throw new Error('Mark stack empty');\n        }\n        this.seek(offset);\n        return this;\n    }\n    /**\n     * Move the pointer offset back to 0.\n     */\n    rewind() {\n        this.offset = 0;\n        return this;\n    }\n    /**\n     * Make sure the buffer has sufficient memory to write a given byteLength at\n     * the current pointer offset.\n     * If the buffer's memory is insufficient, this method will create a new\n     * buffer (a copy) with a length that is twice (byteLength + current offset).\n     * @param byteLength\n     */\n    ensureAvailable(byteLength = 1) {\n        if (!this.available(byteLength)) {\n            const lengthNeeded = this.offset + byteLength;\n            const newLength = lengthNeeded * 2;\n            const newArray = new Uint8Array(newLength);\n            newArray.set(new Uint8Array(this.buffer));\n            this.buffer = newArray.buffer;\n            this.length = this.byteLength = newLength;\n            this._data = new DataView(this.buffer);\n        }\n        return this;\n    }\n    /**\n     * Read a byte and return false if the byte's value is 0, or true otherwise.\n     * Moves pointer forward by one byte.\n     */\n    readBoolean() {\n        return this.readUint8() !== 0;\n    }\n    /**\n     * Read a signed 8-bit integer and move pointer forward by 1 byte.\n     */\n    readInt8() {\n        return this._data.getInt8(this.offset++);\n    }\n    /**\n     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\n     */\n    readUint8() {\n        return this._data.getUint8(this.offset++);\n    }\n    /**\n     * Alias for {@link IOBuffer#readUint8}.\n     */\n    readByte() {\n        return this.readUint8();\n    }\n    /**\n     * Read `n` bytes and move pointer forward by `n` bytes.\n     */\n    readBytes(n = 1) {\n        const bytes = new Uint8Array(n);\n        for (let i = 0; i < n; i++) {\n            bytes[i] = this.readByte();\n        }\n        return bytes;\n    }\n    /**\n     * Read a 16-bit signed integer and move pointer forward by 2 bytes.\n     */\n    readInt16() {\n        const value = this._data.getInt16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\n     */\n    readUint16() {\n        const value = this._data.getUint16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 32-bit signed integer and move pointer forward by 4 bytes.\n     */\n    readInt32() {\n        const value = this._data.getInt32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\n     */\n    readUint32() {\n        const value = this._data.getUint32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit floating number and move pointer forward by 4 bytes.\n     */\n    readFloat32() {\n        const value = this._data.getFloat32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 64-bit floating number and move pointer forward by 8 bytes.\n     */\n    readFloat64() {\n        const value = this._data.getFloat64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit signed integer number and move pointer forward by 8 bytes.\n     */\n    readBigInt64() {\n        const value = this._data.getBigInt64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.\n     */\n    readBigUint64() {\n        const value = this._data.getBigUint64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 1-byte ASCII character and move pointer forward by 1 byte.\n     */\n    readChar() {\n        return String.fromCharCode(this.readInt8());\n    }\n    /**\n     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\n     */\n    readChars(n = 1) {\n        let result = '';\n        for (let i = 0; i < n; i++) {\n            result += this.readChar();\n        }\n        return result;\n    }\n    /**\n     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\n     * forward by `n` bytes.\n     */\n    readUtf8(n = 1) {\n        return decode(this.readBytes(n));\n    }\n    /**\n     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\n     * forward by 1 byte.\n     */\n    writeBoolean(value) {\n        this.writeUint8(value ? 0xff : 0x00);\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\n     */\n    writeInt8(value) {\n        this.ensureAvailable(1);\n        this._data.setInt8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\n     * byte.\n     */\n    writeUint8(value) {\n        this.ensureAvailable(1);\n        this._data.setUint8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * An alias for {@link IOBuffer#writeUint8}.\n     */\n    writeByte(value) {\n        return this.writeUint8(value);\n    }\n    /**\n     * Write all elements of `bytes` as uint8 values and move pointer forward by\n     * `bytes.length` bytes.\n     */\n    writeBytes(bytes) {\n        this.ensureAvailable(bytes.length);\n        for (let i = 0; i < bytes.length; i++) {\n            this._data.setUint8(this.offset++, bytes[i]);\n        }\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit signed integer and move pointer forward by 2\n     * bytes.\n     */\n    writeInt16(value) {\n        this.ensureAvailable(2);\n        this._data.setInt16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\n     * bytes.\n     */\n    writeUint16(value) {\n        this.ensureAvailable(2);\n        this._data.setUint16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit signed integer and move pointer forward by 4\n     * bytes.\n     */\n    writeInt32(value) {\n        this.ensureAvailable(4);\n        this._data.setInt32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\n     * bytes.\n     */\n    writeUint32(value) {\n        this.ensureAvailable(4);\n        this._data.setUint32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit floating number and move pointer forward by 4\n     * bytes.\n     */\n    writeFloat32(value) {\n        this.ensureAvailable(4);\n        this._data.setFloat32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit floating number and move pointer forward by 8\n     * bytes.\n     */\n    writeFloat64(value) {\n        this.ensureAvailable(8);\n        this._data.setFloat64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit signed bigint and move pointer forward by 8\n     * bytes.\n     */\n    writeBigInt64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigInt64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8\n     * bytes.\n     */\n    writeBigUint64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigUint64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write the charCode of `str`'s first character as an 8-bit unsigned integer\n     * and move pointer forward by 1 byte.\n     */\n    writeChar(str) {\n        return this.writeUint8(str.charCodeAt(0));\n    }\n    /**\n     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\n     * and move pointer forward by `str.length` bytes.\n     */\n    writeChars(str) {\n        for (let i = 0; i < str.length; i++) {\n            this.writeUint8(str.charCodeAt(i));\n        }\n        return this;\n    }\n    /**\n     * UTF-8 encode and write `str` to the current pointer offset and move pointer\n     * forward according to the encoded length.\n     */\n    writeUtf8(str) {\n        return this.writeBytes(encode(str));\n    }\n    /**\n     * Export a Uint8Array view of the internal buffer.\n     * The view starts at the byte offset and its length\n     * is calculated to stop at the last written byte or the original length.\n     */\n    toArray() {\n        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n    }\n    /**\n     * Update the last written byte offset\n     * @private\n     */\n    _updateLastWrittenByte() {\n        if (this.offset > this.lastWrittenByte) {\n            this.lastWrittenByte = this.offset;\n        }\n    }\n}\n//# sourceMappingURL=IOBuffer.js.map","\"use strict\";\n/*\n * Copyright 2017 Sam Thorogood. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n(function (scope) {\n    'use strict';\n    // fail early\n    if (scope['TextEncoder'] && scope['TextDecoder']) {\n        return false;\n    }\n    /**\n     * @constructor\n     * @param {string=} utfLabel\n     */\n    function FastTextEncoder(utfLabel = 'utf-8') {\n        if (utfLabel !== 'utf-8') {\n            throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`);\n        }\n    }\n    Object.defineProperty(FastTextEncoder.prototype, 'encoding', {\n        value: 'utf-8',\n    });\n    /**\n     * @param {string} string\n     * @param {{stream: boolean}=} options\n     * @return {!Uint8Array}\n     */\n    FastTextEncoder.prototype.encode = function (string, options = { stream: false }) {\n        if (options.stream) {\n            throw new Error(`Failed to encode: the 'stream' option is unsupported.`);\n        }\n        let pos = 0;\n        const len = string.length;\n        const out = [];\n        let at = 0; // output position\n        let tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n        let target = new Uint8Array((tlen >> 3) << 3); // ... but at 8 byte offset\n        while (pos < len) {\n            let value = string.charCodeAt(pos++);\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < len) {\n                    const extra = string.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n                if (value >= 0xd800 && value <= 0xdbff) {\n                    continue; // drop lone surrogate\n                }\n            }\n            // expand the buffer if we couldn't write 4 bytes\n            if (at + 4 > target.length) {\n                tlen += 8; // minimum extra\n                tlen *= 1.0 + (pos / string.length) * 2; // take 2x the remaining\n                tlen = (tlen >> 3) << 3; // 8 byte offset\n                const update = new Uint8Array(tlen);\n                update.set(target);\n                target = update;\n            }\n            if ((value & 0xffffff80) === 0) {\n                // 1-byte\n                target[at++] = value; // ASCII\n                continue;\n            }\n            else if ((value & 0xfffff800) === 0) {\n                // 2-byte\n                target[at++] = ((value >> 6) & 0x1f) | 0xc0;\n            }\n            else if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                target[at++] = ((value >> 12) & 0x0f) | 0xe0;\n                target[at++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else if ((value & 0xffe00000) === 0) {\n                // 4-byte\n                target[at++] = ((value >> 18) & 0x07) | 0xf0;\n                target[at++] = ((value >> 12) & 0x3f) | 0x80;\n                target[at++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // FIXME: do we care\n                continue;\n            }\n            target[at++] = (value & 0x3f) | 0x80;\n        }\n        return target.slice(0, at);\n    };\n    /**\n     * @constructor\n     * @param {string=} utfLabel\n     * @param {{fatal: boolean}=} options\n     */\n    function FastTextDecoder(utfLabel = 'utf-8', options = { fatal: false }) {\n        if (utfLabel !== 'utf-8') {\n            throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`);\n        }\n        if (options.fatal) {\n            throw new Error(`Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`);\n        }\n    }\n    Object.defineProperty(FastTextDecoder.prototype, 'encoding', {\n        value: 'utf-8',\n    });\n    Object.defineProperty(FastTextDecoder.prototype, 'fatal', { value: false });\n    Object.defineProperty(FastTextDecoder.prototype, 'ignoreBOM', {\n        value: false,\n    });\n    /**\n     * @param {(!ArrayBuffer|!ArrayBufferView)} buffer\n     * @param {{stream: boolean}=} options\n     */\n    FastTextDecoder.prototype.decode = function (buffer, options = { stream: false }) {\n        if (options['stream']) {\n            throw new Error(`Failed to decode: the 'stream' option is unsupported.`);\n        }\n        const bytes = new Uint8Array(buffer);\n        let pos = 0;\n        const len = bytes.length;\n        const out = [];\n        while (pos < len) {\n            const byte1 = bytes[pos++];\n            if (byte1 === 0) {\n                break; // NULL\n            }\n            if ((byte1 & 0x80) === 0) {\n                // 1-byte\n                out.push(byte1);\n            }\n            else if ((byte1 & 0xe0) === 0xc0) {\n                // 2-byte\n                const byte2 = bytes[pos++] & 0x3f;\n                out.push(((byte1 & 0x1f) << 6) | byte2);\n            }\n            else if ((byte1 & 0xf0) === 0xe0) {\n                const byte2 = bytes[pos++] & 0x3f;\n                const byte3 = bytes[pos++] & 0x3f;\n                out.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n            }\n            else if ((byte1 & 0xf8) === 0xf0) {\n                const byte2 = bytes[pos++] & 0x3f;\n                const byte3 = bytes[pos++] & 0x3f;\n                const byte4 = bytes[pos++] & 0x3f;\n                // this can be > 0xffff, so possibly generate surrogates\n                let codepoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n                if (codepoint > 0xffff) {\n                    // codepoint &= ~0x10000;\n                    codepoint -= 0x10000;\n                    out.push(((codepoint >>> 10) & 0x3ff) | 0xd800);\n                    codepoint = 0xdc00 | (codepoint & 0x3ff);\n                }\n                out.push(codepoint);\n            }\n            else {\n                // FIXME: we're ignoring this\n            }\n        }\n        return String.fromCharCode.apply(null, out);\n    };\n    scope['TextEncoder'] = FastTextEncoder;\n    scope['TextDecoder'] = FastTextDecoder;\n})(typeof window !== 'undefined'\n    ? window\n    : typeof self !== 'undefined'\n        ? self\n        : this);\n//# sourceMappingURL=text-encoding-polyfill.js.map"],"names":["decoder","TextDecoder","encoder","TextEncoder","IOBuffer","constructor","data","options","dataIsGiven","ArrayBuffer","this","lastWrittenByte","byteLength","offset","dvOffset","isView","buffer","byteOffset","length","littleEndian","_data","DataView","_mark","_marks","available","isLittleEndian","setLittleEndian","isBigEndian","setBigEndian","skip","n","seek","mark","reset","pushMark","push","popMark","pop","undefined","Error","rewind","ensureAvailable","newLength","newArray","Uint8Array","set","readBoolean","readUint8","readInt8","getInt8","getUint8","readByte","readBytes","bytes","i","readInt16","value","getInt16","readUint16","getUint16","readInt32","getInt32","readUint32","getUint32","readFloat32","getFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readChar","String","fromCharCode","readChars","result","readUtf8","decode","writeBoolean","writeUint8","writeInt8","setInt8","_updateLastWrittenByte","setUint8","writeByte","writeBytes","writeInt16","setInt16","writeUint16","setUint16","writeInt32","setInt32","writeUint32","setUint32","writeFloat32","setFloat32","writeFloat64","setFloat64","writeBigInt64","setBigInt64","writeBigUint64","setBigUint64","writeChar","str","charCodeAt","writeChars","writeUtf8","encode","toArray","scope","FastTextEncoder","utfLabel","RangeError","FastTextDecoder","fatal","Object","defineProperty","prototype","string","stream","pos","len","at","tlen","Math","max","target","extra","update","slice","out","byte1","byte2","byte3","codepoint","apply","window","self"],"sourceRoot":""}